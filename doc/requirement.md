# DLedger

## Assumption
DLedger is built on a system with the following assumption:
- Nodes are authenticated. The identity of each node can be verified using certificate chain.
- Network Partition may occur. The network may partition that causes a two generals problem. 
- Up to k out of n nodes may be compromised. This may cause byzantine generals problem. The compromised node may attempt to 
  1. Insert illegitimate records. 
  2. Modify previously accepted records.
  3. Flood the system with legitimate records.

## Properties

DLedger is a secured distributed logging system. 
It has the following properties:
- Persistence. The records accepted by the system are replicated at least m peers, so they cannot collude.
- Permission. All log entries, and the corresponding data are signed,
  and therefore able to be tracked to the original sender.
- Immutability. All records cannot be modified once accepted, 
  without knowing all keys of the accepting peers. This also means that the system is append-only. 
- Partition Tolerance. Under a network partition, the records are still able to be 
accepted as long as there are sufficient peers for acceptance (k peers).
- Correctness. Records are checked before accepted into the logs. 
- Eventual Consistency. All records will be eventally replicated to all peers if no new records are added.
- Flooding Prevention. The nodes are not able to flood the logger and cause other node to fail.
- Basically Available. The nodes are able to read records even under partitions. 
  (May not be the newest record, and the node may not commit without k peers to accept)

## Why not just build on top of sync protocol?

We consider a na√Øve solution: 

- Each node can be authenticated with a certificate. 
- Each node signs and publish their records.
- The records are replicated to all other nodes using SVS or other sync protocol to all other devices.

Then, we check this solution against the above properties:
- Persistence. No, there is no guarantee with no feedback system. 
- Permission. Yes. 
- Immutability. No, since the producer can send different set of data to different peers. 
- Partition Tolerance. Yes. 
- Correctness. Partially, since each receiver can check for itself only. 
- Eventual Consistency. Yes. 
- Flooding Prevention. No, the producer can generate as many as it wants. 

## Use case

### Abstract use case
Our basic use case is an distributed event logger for a distributed system. 
In this case, each peer may generate a record for each event it encountered. 

However, a compromised node may send false event reports or flood the system. 

Therefore, we use DLedger to ensure the correctness of the system while keeping as 
many legitimate records as possible under dynamic network condition. 

All of our basic analysis of the model should be based on this use case. 

### Certificate Management (Basic Relationship between Pointers)
A more advanced use case is a certificate management logger. 
In this case, each revocation of the certificate should be tracked to the 
generation record, since that is where the record is introduced. 

Therefore, this logger will have an additional layer of pointers. 

The built-in certificate management system also uses this design. 

### Collective Editing

DLedger may not fit in collective editing case easily, since
- Edit frequency are unpredictable. 
  The human-initiated commits are relatively slow, and there may be only a single person making changes, making it look like a flooding. 
- There are no correctness check available. 
- The pointers from edits are pointing to last change, not necessary the verifying records. 

To address the third issue, in introduce the parent change pointer as a separate set of pointer, 
decoupled from the "preceding record" pointer. This way, we can corrective trace the history of the records. 

To address the first issue, we introduce a set of "ACK" record, which are essentially empty record generated by other peers
to verify the human commits. 

This design may not fit to the DLedger model perfectly, but it should work. 

### Coins. 

Coins are also special, because it also needs an additional consistency check on 
double spending. 

To resolve this, we require the BFT tolerance k to be larger than n/2. So an transaction 
is accepted only if a majority of peers endorses it. 
However, this also means that the partition tolerance is damaged, because with this weight, 
only a maximum of 1 partition can be functional at the same time. All other partitions will not have
sufficient peers to make commits. 
